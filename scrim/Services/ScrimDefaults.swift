//
// ScrimDefaults.swift
// scrim

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// Â© 2025 Charles Choi

import Foundation
import OSLog

enum ScrimDefaultsError: Error {
    case unableToAccessScopedResource
    case canNotResolveBookmarkData
}

/// Scrim wrapper for UserDefaults
///
/// Scrim uses `UserDefaults` to store the bookmark data for the URL of the shared
/// secret file generated by Emacs server. This bookmark data is used to provide access to
/// the shared secret file as it is located outside of the sandbox for this app.
///
/// The properties of this class are populated by the contents of this shared secret file.
///
@Observable
public class ScrimDefaults: NSObject {
    /// Emacs server TCP port
    var port: Int?
    /// Emacs server shared secret. This is used by Emacs client to authenticate with the server.
    @objc dynamic var authKey: String?
    /// Emacs server host
    var host: String?
    /// Emacs server pid
    var pid: Int?

    let logger = Logger(subsystem: "com.yummymelon.scrim", category: "userdefaults")

    @MainActor static let shared = ScrimDefaults()

    override init() {
        super.init()
        
        if let data = authBookmark() {
            logger.debug("authBookmark found")
            do {
                try parseAuthBookmarkData(data)
            } catch {
                logger.debug("Unexpected condition in parseAuthBookmarkData: \(error)")
                authKey = "server-unavailable"
            }
        } else {
            logger.debug("no authBookmark")
        }
    }

    func authBookmark(key: String = "authBookmark") -> Data? {
        let defaults = UserDefaults.standard
        return defaults.data(forKey: key)
    }
    
    func parseAuthBookmarkData(_ data: Data) throws {
        var stale = false;

        do {
            // !!!: Note that .withoutImplicitStartAddressing is needed to handle case when Emacs server is not running.
            let bURL = try URL(resolvingBookmarkData: data,
                               options: [.withSecurityScope, .withoutImplicitStartAccessing],
                               bookmarkDataIsStale: &stale)
            
            if bURL.startAccessingSecurityScopedResource() {
                let data = try Data(contentsOf: bURL)
                if let buf = String(data: data, encoding: .utf8) {
                    let tempList = buf.components(separatedBy: .newlines)

                    if let first = tempList.first {
                        let tempList = first.components(separatedBy: .whitespaces)
                        if let hostPort = tempList.first {
                            let tempList2 = hostPort.components(separatedBy: ":")
                            if tempList2.count > 1 {
                                host = tempList2[0]
                                port = Int(tempList2[1])
                                logger.debug("Host: \(self.host ?? "unknown"), Port: \(self.port ?? 0)")
                            }
                        }
                    }

                    if let last = tempList.last {
                        authKey = last
                    }
                }
                
                bURL.stopAccessingSecurityScopedResource()
            } else {
                logger.error("unable to access scoped resource")
                throw ScrimDefaultsError.unableToAccessScopedResource
            }


        } catch {
            logger.error("can not resolve bookmark data")
            throw ScrimDefaultsError.canNotResolveBookmarkData
        }
    }
    
    func setAuthBookmarkData(_ data: Data, key: String = "authBookmark") {
        let defaults = UserDefaults.standard
        defaults.set(data, forKey: key)
    }

    func clearAuthBookmarkData(key: String = "authBookmark") {
        let defaults = UserDefaults.standard
        defaults.removeObject(forKey: key)
        port = nil
        host = nil
        authKey = nil
        pid = nil
    }
}
